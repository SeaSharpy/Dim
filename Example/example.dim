import STD;
namespace Demo;

//using STD; // automatically inserted, adding this would cause an ambiguity error

class Log {
    static double Begin(String label) {
        double now = TimeMS!;
        Print(""); // This works for all methods inside the same class, or you can use the using keyword to get C# using static like behaviour
        Print("== ".Concat(label));
        Print("  start=".Concat(MathC.ToString(now)).Concat(" ms"));
        return now;
    }

    static void End(String label, double start) {
        double end = TimeMS!;
        double elapsed = end - start;
        String line = label.Concat(" done in ")
            .Concat(MathC.ToString(elapsed))
            .Concat(" ms (end=")
            .Concat(MathC.ToString(end))
            .Concat(" ms)");
        Print(line);
    }

    static void Line(String label, String value)
        Print(label.Concat(": ").Concat(value));

    static void Header(String label)
        Print(label.Concat(":"));

    static void Item(String label, String value)
        Print("  ".Concat(label).Concat(" = ").Concat(value));
}

// Vector math with mixed typing, static fields, instance fields, and methods.
class Vector2 {
    float x;
    float y;

    static Vector2 Zero;
    static Vector2 UnitX;
    static Vector2 UnitY;

    static Vector2 New(float px, float py) {
        Vector2 v = new;
        v.Init(px, py);
        return v;
    }

    void Init(float px, float py) {
        self.x = px;
        self.y = py;
    }

    float LenSq! => (self.x * self.x) + (self.y * self.y);

    float Len! {
        return MathF.Sqrt(self.LenSq!);
    }

    Vector2 Add(Vector2 other) {
        Vector2 v = new;
        v.Init(self.x + other.x, self.y + other.y);
        return v;
    }

    static float Dot(Vector2 a, Vector2 b) => (a.x * b.x) + (a.y * b.y);

    static void InitStatics! {
        Zero = New(0, 0);
        UnitX = New(1, 0);
        UnitY = New(0, 1);
    }
}

class Counter {
    static int Created;

    static void Bump!
        Counter.Created = Counter.Created + 1;

    static int Next! {
        Counter.Created = Counter.Created + 1;
        return Counter.Created;
    }
}

class Blob {
    int id;
    double value;
    Vector2 pos;
    String tag;

    static Blob KeepA;
    static Blob KeepB;

    static Blob New(int id, double value, Vector2 pos, String tag) {
        Blob b = new;
        b.Init(id, value, pos, tag);
        return b;
    }

    void Init(int id, double value, Vector2 pos, String tag) {
        self.id = id;
        self.value = value;
        self.pos = pos;
        self.tag = tag;
        Counter.Bump!;
    }

    String ToString! => "Blob(".Concat(MathC.ToString(self.id))
        .Concat(", v=")
        .Concat(MathC.ToString(self.value))
        .Concat(", tag=")
        .Concat(self.tag)
        .Concat(")");
}

class Maybe {
    static Blob? MakeMaybe(bool make) {
        if make;
        {
            Vector2 pos = Vector2.New(2, 3);
            return Blob.New(42, 12.5, pos, "maybe");
        }
        return nil;
    }
}

class ThrowA {
    static ThrowA New! {
        ThrowA e = new;
        return e;
    }
}

class ThrowB {
    static ThrowB New! {
        ThrowB e = new;
        return e;
    }
}

class TryCatchThrowTests {
    static int state;
    static int passCount;
    static int failCount;

    static void Run! {
        double t0 = Log.Begin("Try/catch/throw");

        passCount = 0;
        failCount = 0;

        TestNoThrowSkipsCatch!;
        TestTypeMatchedCatch!;
        TestLaterCatchMatches!;
        TestRethrowToOuterCatch!;
        TestUnmatchedPropagatesToOuter!;
        TestValueLocalInCatchArg!;
        TestClassLocalInCatchArg!;
        TestLocalReadAfterTry!;
        TestMultiLocalAfterCatchArgCall!;
        TestMixedTypeLocalsReadAfterCatch!;
        TestNestedCallArgFromLocalsInCatch!;

        Log.Header("summary");
        Log.Item("passed", MathC.ToString(passCount));
        Log.Item("failed", MathC.ToString(failCount));
        Log.End("Try/catch/throw", t0);
    }

    static void CheckInt(String label, int got, int want) {
        bool ok = got == want;
        if ok;
            passCount = passCount + 1;
        else
            failCount = failCount + 1;
        String line = "got=".Concat(MathC.ToString(got))
            .Concat(" want=")
            .Concat(MathC.ToString(want))
            .Concat(" ok=")
            .Concat(MathC.ToString(ok));
        Log.Item(label, line);
    }

    static void Reset! {
        state = 0;
    }

    static void BodyNoThrow! {
        state = state + 1;
    }

    static void BodyThrowA! {
        throw ThrowA.New!;
    }

    static void BodyThrowB! {
        throw ThrowB.New!;
    }

    static void CatchA! {
        state = state + 100;
    }

    static void CatchB! {
        state = state + 1000;
    }

    static void CatchOuter! {
        state = state + 10000;
    }

    static void CatchWithInt(int v) {
        state = state + v;
    }

    static void CatchWithString(String s) {
        state = state + s.Length!;
    }

    static int Sum2(int a, int b) => a + b;

    static int Sum3(int a, int b, int c) => a + b + c;

    static void CatchWithComputedInt(int v) {
        state = state + v;
    }

    static void RethrowA! {
        throw ThrowA.New!;
    }

    static void InnerWrongCatchOnlyB! {
        try BodyThrowA!;
        catch ThrowB CatchB!;
    }

    static void InnerRethrow! {
        try BodyThrowA!;
        catch ThrowA RethrowA!;
    }

    static void TestNoThrowSkipsCatch! {
        Reset!;
        try BodyNoThrow!;
        catch ThrowA CatchA!;
        CheckInt("no-throw skips catch", state, 1);
    }

    static void TestTypeMatchedCatch! {
        Reset!;
        try BodyThrowA!;
        catch ThrowA CatchA!;
        catch ThrowB CatchB!;
        CheckInt("throw A hits catch A", state, 100);
    }

    static void TestLaterCatchMatches! {
        Reset!;
        try BodyThrowB!;
        catch ThrowA CatchA!;
        catch ThrowB CatchB!;
        CheckInt("throw B hits later catch", state, 1000);
    }

    static void TestRethrowToOuterCatch! {
        Reset!;
        try InnerRethrow!;
        catch ThrowA CatchOuter!;
        CheckInt("rethrow reaches outer catch", state, 10000);
    }

    static void TestUnmatchedPropagatesToOuter! {
        Reset!;
        try InnerWrongCatchOnlyB!;
        catch ThrowA CatchOuter!;
        CheckInt("unmatched inner catch propagates", state, 10000);
    }

    static void TestValueLocalInCatchArg! {
        Reset!;
        int carry = 37;
        try BodyThrowA!;
        catch ThrowA CatchWithInt(carry);
        CheckInt("value local in catch arg", state, 37);
    }

    static void TestClassLocalInCatchArg! {
        Reset!;
        String txt = "abcde";
        try BodyThrowA!;
        catch ThrowA CatchWithString(txt);
        CheckInt("class local in catch arg", state, 5);
    }

    static void TestLocalReadAfterTry! {
        Reset!;
        int carry = 9;
        try BodyThrowA!;
        catch ThrowA CatchA!;
        int after = carry + state;
        CheckInt("local read after try", after, 109);
    }

    static void TestMultiLocalAfterCatchArgCall! {
        Reset!;
        int a = 5;
        int b = 7;
        int c = 11;
        try BodyThrowA!;
        catch ThrowA CatchWithComputedInt(Sum3(a, b, c));
        int after = Sum2(a, b) + c + state;
        CheckInt("multi local after catch", after, 46);
    }

    static void TestMixedTypeLocalsReadAfterCatch! {
        Reset!;
        String s = "wolf";
        int n = 8;
        try BodyThrowA!;
        catch ThrowA CatchWithComputedInt(Sum2(n, s.Length!));
        int after = n + s.Length! + state;
        CheckInt("mixed locals after catch", after, 24);
    }

    static void TestNestedCallArgFromLocalsInCatch! {
        Reset!;
        int x = 2;
        int y = 3;
        int z = 4;
        try BodyThrowA!;
        catch ThrowA CatchWithComputedInt(Sum2(Sum2(x, y), z));
        int after = state + Sum3(x, y, z);
        CheckInt("nested catch arg locals", after, 18);
    }
}

interface PetLike {
    int Score();
    String Label();
}

class Creature {
    int age;

    static Creature NewAge(int v) {
        Creature c = new;
        c.age = v;
        return c;
    }

    int NextYear! => self.age + 1;
}

class Dog : Creature, PetLike {
    int bark;

    static Dog New! {
        Dog d = new;
        return d;
    }

    static Dog NewAt(int age, int bark) {
        Dog d = new;
        d.age = age;
        d.bark = bark;
        return d;
    }

    void Train(int hours) {
        self.bark = self.bark + hours;
        self.age = self.age + 1;
    }

    int Score! => (self.age * 10) + self.bark;

    String Label! => "Dog(age=".Concat(MathC.ToString(self.age))
        .Concat(", bark=")
        .Concat(MathC.ToString(self.bark))
        .Concat(")");

    int OnlyDog! => self.age + self.bark;
}

class Cat : Creature, PetLike {
    int naps;

    static Cat New! {
        Cat c = new;
        return c;
    }

    static Cat NewAt(int age, int naps) {
        Cat c = new;
        c.age = age;
        c.naps = naps;
        return c;
    }

    void SleepMore(int count) {
        self.naps = self.naps + count;
        self.age = self.age + 1;
    }

    int Score! => (self.age * 5) + self.naps;

    String Label! => "Cat(age=".Concat(MathC.ToString(self.age))
        .Concat(", naps=")
        .Concat(MathC.ToString(self.naps))
        .Concat(")");

    int OnlyCat! => self.age + self.naps;
}

class InheritanceTests {
    static void Run! {
        double t0 = Log.Begin("Inheritance");

        Dog d = Dog.NewAt(10, 7);
        Cat c = Cat.NewAt(3, 4);
        Creature baseOnly = Creature.NewAge(20);

        d.Train(2);
        c.SleepMore(3);
        int baseNext = baseOnly.NextYear!;

        Creature asCreature = d; // compile-time upcast Dog -> Creature
        asCreature.age = asCreature.age + 5; // inherited field through base view

        Any boxedFromCreature = asCreature.Box!; // put Dog instance into Any through Creature view
        Dog? roundTripDog = Dog.Unbox(boxedFromCreature); // cast back out
        Creature? roundTripCreature = Creature.Unbox(boxedFromCreature); // exact-type unbox (expected nil for Dog)
        PetLike petFromDog = d; // class -> interface assignment

        int petScore = -1;
        String petLabel = "none";
        is Dog fromPet = petFromDog;
        {
            petScore = fromPet.Score!;
            petLabel = fromPet.Label!;
        }
        else
        {
            petScore = -999;
            petLabel = "bad";
        }

        int noElseHit = 0;
        is Cat noElse = petFromDog;
            noElseHit = 1;

        int exprDogOwn = is Dog x = petFromDog; x.OnlyDog! else -1;
        int exprCatOwn = is Cat y = petFromDog; y.OnlyCat! else -2;
        Dog? asDog = petFromDog as Dog;
        Cat? asCat = petFromDog as Cat;
        int asDogOwn = -3;
        if asDog != nil;
            asDogOwn = asDog@.OnlyDog!;

        int dogScore = d.Score!;
        int catScore = c.Score!;
        int dogOwn = d.OnlyDog!;
        int catOwn = c.OnlyCat!;
        int dogRoundTripOwn = -1;
        if roundTripDog != nil;
            dogRoundTripOwn = roundTripDog@.OnlyDog!;

        Log.Item("dog label", d.Label!);
        Log.Item("cat label", c.Label!);
        Log.Item("base next", MathC.ToString(baseNext));
        Log.Item("dog score", MathC.ToString(dogScore));
        Log.Item("cat score", MathC.ToString(catScore));
        Log.Item("dog as creature age", MathC.ToString(asCreature.age));
        Log.Item("dog roundtrip ok", MathC.ToString(roundTripDog != nil));
        Log.Item("creature exact unbox nil", MathC.ToString(roundTripCreature == nil));
        Log.Item("pet score via is", MathC.ToString(petScore));
        Log.Item("pet label via is", petLabel);
        Log.Item("expr dog own", MathC.ToString(exprDogOwn));
        Log.Item("expr cat own", MathC.ToString(exprCatOwn));
        Log.Item("as dog ok", MathC.ToString(asDog != nil));
        Log.Item("as cat nil", MathC.ToString(asCat == nil));
        Log.Item("as dog own", MathC.ToString(asDogOwn));
        Log.Item("is no-else hit", MathC.ToString(noElseHit));

        Log.Item("dog own", MathC.ToString(dogOwn));
        Log.Item("cat own", MathC.ToString(catOwn));
        Log.Item("dog roundtrip own", MathC.ToString(dogRoundTripOwn));
        Log.Item("ok",
            MathC.ToString(
                baseNext == 21 &&
                dogScore == 169 &&
                catScore == 27 &&
                asCreature.age == 16 &&
                dogOwn == 25 &&
                catOwn == 11 &&
                roundTripDog != nil &&
                roundTripCreature == nil &&
                dogRoundTripOwn == dogOwn &&
                petScore == dogScore &&
                exprDogOwn == dogOwn &&
                exprCatOwn == -2 &&
                asDog != nil &&
                asCat == nil &&
                asDogOwn == dogOwn &&
                noElseHit == 0));

        Log.End("Inheritance", t0);
    }
}

class StdTests {
    static void Run! {
        double t0 = Log.Begin("STD String + core");

        String a = "alpha";
        String b = "beta";
        String joined = a.Concat(" + ").Concat(b);
        String fromString = String.FromString(joined);
        String cloned = String.Clone(fromString);

        int len = cloned.Length!;
        bool empty = cloned.IsEmpty!;
        bool eq = String.Equals(a, b);
        int cmp = String.Compare(a, b);

        bool vBool = true;
        int vInt = -42;
        uint vUInt = 42;
        long vLong = -42000;
        ulong vULong = 42000;
        float vFloat = 1.25;
        double vDouble = -3.5;
        byte vByte = 200;
        sbyte vSByte = -100;
        char vChar = 65;
        short vShort = -32000;
        ushort vUShort = 65000;

        String sBool = MathC.ToString(vBool);
        String sInt = MathC.ToString(vInt);
        String sUInt = MathC.ToString(vUInt);
        String sLong = MathC.ToString(vLong);
        String sULong = MathC.ToString(vULong);
        String sFloat = MathC.ToString(vFloat);
        String sDouble = MathC.ToString(vDouble);
        String sByte = MathC.ToString(vByte);
        String sSByte = MathC.ToString(vSByte);
        String sChar = MathC.ToString(vChar);
        String sShort = MathC.ToString(vShort);
        String sUShort = MathC.ToString(vUShort);

        int sumLen = sBool.Length! + sInt.Length! + sUInt.Length! + sLong.Length!;
        sumLen = sumLen + sULong.Length! + sFloat.Length! + sDouble.Length! + sByte.Length!;
        sumLen = sumLen + sSByte.Length! + sChar.Length! + sShort.Length! + sUShort.Length!;

        String samples = "bool=".Concat(sBool)
            .Concat(" int=")
            .Concat(sInt)
            .Concat(" float=")
            .Concat(sFloat)
            .Concat(" double=")
            .Concat(sDouble);
        Log.Header("strings");
        Log.Item("a", a);
        Log.Item("b", b);
        Log.Item("joined", joined);
        Log.Item("len", MathC.ToString(len));
        Log.Item("empty", MathC.ToString(empty));
        Log.Item("equals", MathC.ToString(eq));
        Log.Item("compare", MathC.ToString(cmp));
        Log.Item("sumLen", MathC.ToString(sumLen));
        Log.Item("samples", samples);
        String lengthDesc = if len > 0; "non-empty" else "empty";
        Log.Item("if expression", lengthDesc);
        Any anyStr = a.Box!;
        String? unboxedStr = String.Unbox(anyStr);
        Vector2 vAnySrc = Vector2.New(5, 6);
        Any anyVec = vAnySrc.Box!;
        String? wrongUnbox = String.Unbox(anyVec);
        String unboxedLabel = "nil";
        if unboxedStr != nil;
            unboxedLabel = unboxedStr@;
        Log.Header("any");
        Log.Item("box string ok", MathC.ToString(unboxedStr != nil));
        Log.Item("unbox string", unboxedLabel);
        Log.Item("wrong type nil", MathC.ToString(wrongUnbox == nil));

        Log.End("STD String + core", t0);
    }
}

class MathTests {
    static void Run! {
        double t0 = Log.Begin("Math + operators");

        // Double math
        double d0 = 25.0;
        double d1 = -3.5;
        double dSqrt = Math.Sqrt(d0);
        double dPow = Math.Pow(2.0, 8.0);
        double dSin = Math.Sin(0.5);
        double dCos = Math.Cos(0.5);
        double dTan = Math.Tan(0.1);
        double dAsin = Math.Asin(0.5);
        double dAcos = Math.Acos(0.5);
        double dAtan = Math.Atan(0.5);
        double dAtan2 = Math.Atan2(1.0, 2.0);
        double dExp = Math.Exp(1.0);
        double dLog = Math.Log(10.0);
        double dLog10 = Math.Log10(1000.0);
        double dFloor = Math.Floor(3.9);
        double dCeil = Math.Ceil(3.1);
        double dRound = Math.Round(3.6);
        double dFmod = Math.Fmod(7.5, 2.0);
        double dAbs = Math.Abs(d1);
        double dMin = Math.Min(d0, d1);
        double dMax = Math.Max(d0, d1);

        // Float math
        float f0 = 9.0;
        float f1 = -2.5;
        float fSqrt = MathF.Sqrt(f0);
        float fPow = MathF.Pow(2.0, 3.0);
        float fSin = MathF.Sin(0.5);
        float fCos = MathF.Cos(0.5);
        float fTan = MathF.Tan(0.1);
        float fAsin = MathF.Asin(0.5);
        float fAcos = MathF.Acos(0.5);
        float fAtan = MathF.Atan(0.5);
        float fAtan2 = MathF.Atan2(1.0, 2.0);
        float fExp = MathF.Exp(1.0);
        float fLog = MathF.Log(10.0);
        float fLog10 = MathF.Log10(1000.0);
        float fFloor = MathF.Floor(3.9);
        float fCeil = MathF.Ceil(3.1);
        float fRound = MathF.Round(3.6);
        float fFmod = MathF.Fmod(7.5, 2.0);
        float fAbs = MathF.Abs(f1);
        float fMin = MathF.Min(f0, f1);
        float fMax = MathF.Max(f0, f1);

        // Integer math helpers
        int i0 = -123;
        int i1 = 456;
        int iMin = MathI.MinInt(i0, i1);
        int iMax = MathI.MaxInt(i0, i1);
        int iClamp = MathI.ClampInt(123, 0, 100);
        int iAbs = MathI.AbsInt(i0);

        uint ui0 = 10;
        uint ui1 = 3;
        uint uiMin = MathI.MinUInt(ui0, ui1);
        uint uiMax = MathI.MaxUInt(ui0, ui1);
        uint uiClamp = MathI.ClampUInt(100, 0, 255);

        long l0 = -1000;
        long l1 = 2000;
        long lMin = MathI.MinLong(l0, l1);
        long lMax = MathI.MaxLong(l0, l1);
        long lClamp = MathI.ClampLong(2500, -100, 100);
        long lAbs = MathI.AbsLong(l0);

        ulong ul0 = 5;
        ulong ul1 = 9;
        ulong ulMin = MathI.MinULong(ul0, ul1);
        ulong ulMax = MathI.MaxULong(ul0, ul1);
        ulong ulClamp = MathI.ClampULong(99, 0, 10);

        short s0 = -32000;
        short s1 = 12000;
        short sMin = MathI.MinShort(s0, s1);
        short sMax = MathI.MaxShort(s0, s1);
        short sClamp = MathI.ClampShort(123, -10, 10);
        short sAbs = MathI.AbsShort(s0);

        ushort us0 = 65000;
        ushort us1 = 42;
        ushort usMin = MathI.MinUShort(us0, us1);
        ushort usMax = MathI.MaxUShort(us0, us1);
        ushort usClamp = MathI.ClampUShort(500, 0, 255);

        sbyte sb0 = -100;
        sbyte sb1 = 55;
        sbyte sbMin = MathI.MinSByte(sb0, sb1);
        sbyte sbMax = MathI.MaxSByte(sb0, sb1);
        sbyte sbClamp = MathI.ClampSByte(40, -20, 20);
        sbyte sbAbs = MathI.AbsSByte(sb0);

        byte b0 = 200;
        byte b1 = 7;
        byte bMin = MathI.MinByte(b0, b1);
        byte bMax = MathI.MaxByte(b0, b1);
        byte bClamp = MathI.ClampByte(250, 0, 255);

        // Operators, literals, and precedence
        int hx = 0x2A;
        int bn = 0b101010;
        int sh = (hx << 2) + (bn >> 1);
        int bw = (hx & bn) | (hx ^ bn);
        bool logic = (i0 < i1) && (sh > 0) || false;
        bool neg = !logic;
        int unary = -i0 + +i1;
        int bitflip = ~i1;

        // Vector ops
        Vector2 a = Vector2.New(3, 4);
        Vector2 b = Vector2.New(-2, 5);
        Vector2 c = a.Add(b);
        float len = c.Len!;
        float dot = Vector2.Dot(a, b);

        double sumD = dSqrt + dPow + dSin + dCos + dTan + dAsin + dAcos + dAtan + dAtan2;
        sumD = sumD + dExp + dLog + dLog10 + dFloor + dCeil + dRound + dFmod + dAbs + dMin + dMax;
        sumD = sumD + MathC.ToDouble(fSqrt + fPow + fSin + fCos + fTan + fAsin + fAcos + fAtan + fAtan2);
        sumD = sumD + MathC.ToDouble(fExp + fLog + fLog10 + fFloor + fCeil + fRound + fFmod + fAbs + fMin + fMax);

        long sumI = MathC.ToLong(iMin + iMax + iClamp + iAbs + MathC.ToInt(uiMin + uiMax + uiClamp));
        sumI = sumI + lMin + lMax + lClamp + lAbs + MathC.ToLong(ulMin + ulMax + ulClamp);
        sumI = sumI + MathC.ToLong(sMin + sMax + sClamp + sAbs + MathC.ToShort(usMin + usMax + usClamp));
        sumI = sumI + MathC.ToLong(sbMin + sbMax + sbClamp + sbAbs + MathC.ToSByte(bMin + bMax + bClamp));

        String report = "len=".Concat(MathC.ToString(len))
            .Concat(" dot=")
            .Concat(MathC.ToString(dot));
        // Use some results so nothing is dead
        int sink = iMin + iMax + iClamp + iAbs + unary + bitflip + sh + bw;
        sink = sink + MathC.ToInt(neg);

        String dLine = "sqrt=".Concat(MathC.ToString(dSqrt))
            .Concat(" pow=")
            .Concat(MathC.ToString(dPow))
            .Concat(" sin=")
            .Concat(MathC.ToString(dSin))
            .Concat(" cos=")
            .Concat(MathC.ToString(dCos))
            .Concat(" tan=")
            .Concat(MathC.ToString(dTan))
            .Concat(" min=")
            .Concat(MathC.ToString(dMin))
            .Concat(" max=")
            .Concat(MathC.ToString(dMax));

        String fLine = "sqrt=".Concat(MathC.ToString(fSqrt))
            .Concat(" pow=")
            .Concat(MathC.ToString(fPow))
            .Concat(" sin=")
            .Concat(MathC.ToString(fSin))
            .Concat(" cos=")
            .Concat(MathC.ToString(fCos))
            .Concat(" tan=")
            .Concat(MathC.ToString(fTan))
            .Concat(" min=")
            .Concat(MathC.ToString(fMin))
            .Concat(" max=")
            .Concat(MathC.ToString(fMax));

        String iLine = "iMin=".Concat(MathC.ToString(iMin))
            .Concat(" iMax=")
            .Concat(MathC.ToString(iMax))
            .Concat(" iClamp=")
            .Concat(MathC.ToString(iClamp))
            .Concat(" iAbs=")
            .Concat(MathC.ToString(iAbs));

        String uLine = "uiMin=".Concat(MathC.ToString(uiMin))
            .Concat(" uiMax=")
            .Concat(MathC.ToString(uiMax))
            .Concat(" uiClamp=")
            .Concat(MathC.ToString(uiClamp));

        String lLine = "lMin=".Concat(MathC.ToString(lMin))
            .Concat(" lMax=")
            .Concat(MathC.ToString(lMax))
            .Concat(" lClamp=")
            .Concat(MathC.ToString(lClamp))
            .Concat(" lAbs=")
            .Concat(MathC.ToString(lAbs));

        String shLine = "short(min/max/clamp/abs)="
            .Concat(MathC.ToString(sMin))
            .Concat("/")
            .Concat(MathC.ToString(sMax))
            .Concat("/")
            .Concat(MathC.ToString(sClamp))
            .Concat("/")
            .Concat(MathC.ToString(sAbs));

        String bLine = "byte(min/max/clamp)="
            .Concat(MathC.ToString(bMin))
            .Concat("/")
            .Concat(MathC.ToString(bMax))
            .Concat("/")
            .Concat(MathC.ToString(bClamp));

        String opLine = "hx=".Concat(MathC.ToString(hx))
            .Concat(" bn=")
            .Concat(MathC.ToString(bn))
            .Concat(" sh=")
            .Concat(MathC.ToString(sh))
            .Concat(" bw=")
            .Concat(MathC.ToString(bw))
            .Concat(" neg=")
            .Concat(MathC.ToString(neg))
            .Concat(" unary=")
            .Concat(MathC.ToString(unary))
            .Concat(" bitflip=")
            .Concat(MathC.ToString(bitflip));

        Log.Header("results");
        Log.Item("double", dLine);
        Log.Item("float", fLine);
        Log.Item("ints", iLine);
        Log.Item("uints", uLine);
        Log.Item("longs", lLine);
        Log.Item("shorts", shLine);
        Log.Item("bytes", bLine);
        Log.Item("ops", opLine);
        Log.Item("vector", report);
        Log.Item("mathD", MathC.ToString(sumD));
        Log.Item("mathI", MathC.ToString(sumI));
        Log.Item("sink", MathC.ToString(sink));

        Log.End("Math + operators", t0);
    }
}

class ConvertTests {
    static void Run! {
        double t0 = Log.Begin("MathC conversions");

        bool vBool = true;
        int vInt = -1234;
        uint vUInt = 1234;
        long vLong = -5678;
        ulong vULong = 5678;
        float vFloat = 1.5;
        double vDouble = -2.25;
        byte vByte = 200;
        sbyte vSByte = -100;
        char vChar = 65;
        short vShort = -32000;
        ushort vUShort = 65000;

        // BoolFrom*
        bool b0 = MathC.ToBool(vBool);
        bool b1 = MathC.ToBool(vInt);
        bool b2 = MathC.ToBool(vUInt);
        bool b3 = MathC.ToBool(vLong);
        bool b4 = MathC.ToBool(vULong);
        bool b5 = MathC.ToBool(vFloat);
        bool b6 = MathC.ToBool(vDouble);
        bool b7 = MathC.ToBool(vByte);
        bool b8 = MathC.ToBool(vSByte);
        bool b9 = MathC.ToBool(vChar);
        bool b10 = MathC.ToBool(vShort);
        bool b11 = MathC.ToBool(vUShort);

        // IntFrom*
        int i0 = MathC.ToInt(vBool);
        int i1 = MathC.ToInt(vInt);
        int i2 = MathC.ToInt(vUInt);
        int i3 = MathC.ToInt(vLong);
        int i4 = MathC.ToInt(vULong);
        int i5 = MathC.ToInt(vFloat);
        int i6 = MathC.ToInt(vDouble);
        int i7 = MathC.ToInt(vByte);
        int i8 = MathC.ToInt(vSByte);
        int i9 = MathC.ToInt(vChar);
        int i10 = MathC.ToInt(vShort);
        int i11 = MathC.ToInt(vUShort);

        // UIntFrom*
        uint u0 = MathC.ToUInt(vBool);
        uint u1 = MathC.ToUInt(vInt);
        uint u2 = MathC.ToUInt(vUInt);
        uint u3 = MathC.ToUInt(vLong);
        uint u4 = MathC.ToUInt(vULong);
        uint u5 = MathC.ToUInt(vFloat);
        uint u6 = MathC.ToUInt(vDouble);
        uint u7 = MathC.ToUInt(vByte);
        uint u8 = MathC.ToUInt(vSByte);
        uint u9 = MathC.ToUInt(vChar);
        uint u10 = MathC.ToUInt(vShort);
        uint u11 = MathC.ToUInt(vUShort);

        // LongFrom*
        long l0 = MathC.ToLong(vBool);
        long l1 = MathC.ToLong(vInt);
        long l2 = MathC.ToLong(vUInt);
        long l3 = MathC.ToLong(vLong);
        long l4 = MathC.ToLong(vULong);
        long l5 = MathC.ToLong(vFloat);
        long l6 = MathC.ToLong(vDouble);
        long l7 = MathC.ToLong(vByte);
        long l8 = MathC.ToLong(vSByte);
        long l9 = MathC.ToLong(vChar);
        long l10 = MathC.ToLong(vShort);
        long l11 = MathC.ToLong(vUShort);

        // ULongFrom*
        ulong ul0 = MathC.ToULong(vBool);
        ulong ul1 = MathC.ToULong(vInt);
        ulong ul2 = MathC.ToULong(vUInt);
        ulong ul3 = MathC.ToULong(vLong);
        ulong ul4 = MathC.ToULong(vULong);
        ulong ul5 = MathC.ToULong(vFloat);
        ulong ul6 = MathC.ToULong(vDouble);
        ulong ul7 = MathC.ToULong(vByte);
        ulong ul8 = MathC.ToULong(vSByte);
        ulong ul9 = MathC.ToULong(vChar);
        ulong ul10 = MathC.ToULong(vShort);
        ulong ul11 = MathC.ToULong(vUShort);

        // FloatFrom*
        float f0 = MathC.ToFloat(vBool);
        float f1 = MathC.ToFloat(vInt);
        float f2 = MathC.ToFloat(vUInt);
        float f3 = MathC.ToFloat(vLong);
        float f4 = MathC.ToFloat(vULong);
        float f5 = MathC.ToFloat(vFloat);
        float f6 = MathC.ToFloat(vDouble);
        float f7 = MathC.ToFloat(vByte);
        float f8 = MathC.ToFloat(vSByte);
        float f9 = MathC.ToFloat(vChar);
        float f10 = MathC.ToFloat(vShort);
        float f11 = MathC.ToFloat(vUShort);

        // DoubleFrom*
        double d0 = MathC.ToDouble(vBool);
        double d1 = MathC.ToDouble(vInt);
        double d2 = MathC.ToDouble(vUInt);
        double d3 = MathC.ToDouble(vLong);
        double d4 = MathC.ToDouble(vULong);
        double d5 = MathC.ToDouble(vFloat);
        double d6 = MathC.ToDouble(vDouble);
        double d7 = MathC.ToDouble(vByte);
        double d8 = MathC.ToDouble(vSByte);
        double d9 = MathC.ToDouble(vChar);
        double d10 = MathC.ToDouble(vShort);
        double d11 = MathC.ToDouble(vUShort);

        // ByteFrom*
        byte by0 = MathC.ToByte(vBool);
        byte by1 = MathC.ToByte(vInt);
        byte by2 = MathC.ToByte(vUInt);
        byte by3 = MathC.ToByte(vLong);
        byte by4 = MathC.ToByte(vULong);
        byte by5 = MathC.ToByte(vFloat);
        byte by6 = MathC.ToByte(vDouble);
        byte by7 = MathC.ToByte(vByte);
        byte by8 = MathC.ToByte(vSByte);
        byte by9 = MathC.ToByte(vChar);
        byte by10 = MathC.ToByte(vShort);
        byte by11 = MathC.ToByte(vUShort);

        // SByteFrom*
        sbyte sb0 = MathC.ToSByte(vBool);
        sbyte sb1 = MathC.ToSByte(vInt);
        sbyte sb2 = MathC.ToSByte(vUInt);
        sbyte sb3 = MathC.ToSByte(vLong);
        sbyte sb4 = MathC.ToSByte(vULong);
        sbyte sb5 = MathC.ToSByte(vFloat);
        sbyte sb6 = MathC.ToSByte(vDouble);
        sbyte sb7 = MathC.ToSByte(vByte);
        sbyte sb8 = MathC.ToSByte(vSByte);
        sbyte sb9 = MathC.ToSByte(vChar);
        sbyte sb10 = MathC.ToSByte(vShort);
        sbyte sb11 = MathC.ToSByte(vUShort);

        // CharFrom*
        char ch0 = MathC.ToChar(vBool);
        char ch1 = MathC.ToChar(vInt);
        char ch2 = MathC.ToChar(vUInt);
        char ch3 = MathC.ToChar(vLong);
        char ch4 = MathC.ToChar(vULong);
        char ch5 = MathC.ToChar(vFloat);
        char ch6 = MathC.ToChar(vDouble);
        char ch7 = MathC.ToChar(vByte);
        char ch8 = MathC.ToChar(vSByte);
        char ch9 = MathC.ToChar(vChar);
        char ch10 = MathC.ToChar(vShort);
        char ch11 = MathC.ToChar(vUShort);

        // ShortFrom*
        short sh0 = MathC.ToShort(vBool);
        short sh1 = MathC.ToShort(vInt);
        short sh2 = MathC.ToShort(vUInt);
        short sh3 = MathC.ToShort(vLong);
        short sh4 = MathC.ToShort(vULong);
        short sh5 = MathC.ToShort(vFloat);
        short sh6 = MathC.ToShort(vDouble);
        short sh7 = MathC.ToShort(vByte);
        short sh8 = MathC.ToShort(vSByte);
        short sh9 = MathC.ToShort(vChar);
        short sh10 = MathC.ToShort(vShort);
        short sh11 = MathC.ToShort(vUShort);

        // UShortFrom*
        ushort us0 = MathC.ToUShort(vBool);
        ushort us1 = MathC.ToUShort(vInt);
        ushort us2 = MathC.ToUShort(vUInt);
        ushort us3 = MathC.ToUShort(vLong);
        ushort us4 = MathC.ToUShort(vULong);
        ushort us5 = MathC.ToUShort(vFloat);
        ushort us6 = MathC.ToUShort(vDouble);
        ushort us7 = MathC.ToUShort(vByte);
        ushort us8 = MathC.ToUShort(vSByte);
        ushort us9 = MathC.ToUShort(vChar);
        ushort us10 = MathC.ToUShort(vShort);
        ushort us11 = MathC.ToUShort(vUShort);

        // Summaries to keep values alive
        int sumI = i0 + i1 + i2 + i3 + i4 + i5 + i6 + i7 + i8 + i9 + i10 + i11;
        sumI = sumI + MathC.ToInt(u0) + MathC.ToInt(u1) + MathC.ToInt(u2);
        sumI = sumI + MathC.ToInt(u3) + MathC.ToInt(u4) + MathC.ToInt(u5);
        sumI = sumI + MathC.ToInt(u6) + MathC.ToInt(u7) + MathC.ToInt(u8);
        sumI = sumI + MathC.ToInt(u9) + MathC.ToInt(u10) + MathC.ToInt(u11);
        sumI = sumI + MathC.ToInt(b0) + MathC.ToInt(b1) + MathC.ToInt(b2);
        sumI = sumI + MathC.ToInt(b3) + MathC.ToInt(b4) + MathC.ToInt(b5);
        sumI = sumI + MathC.ToInt(b6) + MathC.ToInt(b7) + MathC.ToInt(b8);
        sumI = sumI + MathC.ToInt(b9) + MathC.ToInt(b10) + MathC.ToInt(b11);

        long sumL = l0 + l1 + l2 + l3 + l4 + l5 + l6 + l7 + l8 + l9 + l10 + l11;
        sumL = sumL + MathC.ToLong(ul0) + MathC.ToLong(ul1) + MathC.ToLong(ul2);
        sumL = sumL + MathC.ToLong(ul3) + MathC.ToLong(ul4) + MathC.ToLong(ul5);
        sumL = sumL + MathC.ToLong(ul6) + MathC.ToLong(ul7) + MathC.ToLong(ul8);
        sumL = sumL + MathC.ToLong(ul9) + MathC.ToLong(ul10) + MathC.ToLong(ul11);

        double sumD = d0 + d1 + d2 + d3 + d4 + d5 + d6 + d7 + d8 + d9 + d10 + d11;
        sumD = sumD + MathC.ToDouble(f0) + MathC.ToDouble(f1) + MathC.ToDouble(f2);
        sumD = sumD + MathC.ToDouble(f3) + MathC.ToDouble(f4) + MathC.ToDouble(f5);
        sumD = sumD + MathC.ToDouble(f6) + MathC.ToDouble(f7) + MathC.ToDouble(f8);
        sumD = sumD + MathC.ToDouble(f9) + MathC.ToDouble(f10) + MathC.ToDouble(f11);

        sumD = sumD + MathC.ToDouble(by0) + MathC.ToDouble(by1) + MathC.ToDouble(by2);
        sumD = sumD + MathC.ToDouble(by3) + MathC.ToDouble(by4) + MathC.ToDouble(by5);
        sumD = sumD + MathC.ToDouble(by6) + MathC.ToDouble(by7) + MathC.ToDouble(by8);
        sumD = sumD + MathC.ToDouble(by9) + MathC.ToDouble(by10) + MathC.ToDouble(by11);

        sumD = sumD + MathC.ToDouble(sb0) + MathC.ToDouble(sb1) + MathC.ToDouble(sb2);
        sumD = sumD + MathC.ToDouble(sb3) + MathC.ToDouble(sb4) + MathC.ToDouble(sb5);
        sumD = sumD + MathC.ToDouble(sb6) + MathC.ToDouble(sb7) + MathC.ToDouble(sb8);
        sumD = sumD + MathC.ToDouble(sb9) + MathC.ToDouble(sb10) + MathC.ToDouble(sb11);

        sumD = sumD + MathC.ToDouble(ch0) + MathC.ToDouble(ch1) + MathC.ToDouble(ch2);
        sumD = sumD + MathC.ToDouble(ch3) + MathC.ToDouble(ch4) + MathC.ToDouble(ch5);
        sumD = sumD + MathC.ToDouble(ch6) + MathC.ToDouble(ch7) + MathC.ToDouble(ch8);
        sumD = sumD + MathC.ToDouble(ch9) + MathC.ToDouble(ch10) + MathC.ToDouble(ch11);

        sumD = sumD + MathC.ToDouble(sh0) + MathC.ToDouble(sh1) + MathC.ToDouble(sh2);
        sumD = sumD + MathC.ToDouble(sh3) + MathC.ToDouble(sh4) + MathC.ToDouble(sh5);
        sumD = sumD + MathC.ToDouble(sh6) + MathC.ToDouble(sh7) + MathC.ToDouble(sh8);
        sumD = sumD + MathC.ToDouble(sh9) + MathC.ToDouble(sh10) + MathC.ToDouble(sh11);

        sumD = sumD + MathC.ToDouble(us0) + MathC.ToDouble(us1) + MathC.ToDouble(us2);
        sumD = sumD + MathC.ToDouble(us3) + MathC.ToDouble(us4) + MathC.ToDouble(us5);
        sumD = sumD + MathC.ToDouble(us6) + MathC.ToDouble(us7) + MathC.ToDouble(us8);
        sumD = sumD + MathC.ToDouble(us9) + MathC.ToDouble(us10) + MathC.ToDouble(us11);

        String inputs = "bool=".Concat(MathC.ToString(vBool))
            .Concat(" int=")
            .Concat(MathC.ToString(vInt))
            .Concat(" uint=")
            .Concat(MathC.ToString(vUInt))
            .Concat(" long=")
            .Concat(MathC.ToString(vLong))
            .Concat(" float=")
            .Concat(MathC.ToString(vFloat))
            .Concat(" double=")
            .Concat(MathC.ToString(vDouble))
            .Concat(" byte=")
            .Concat(MathC.ToString(vByte))
            .Concat(" char=")
            .Concat(MathC.ToString(vChar));

        String sample = "bool->int=".Concat(MathC.ToString(i0))
            .Concat(" int->float=")
            .Concat(MathC.ToString(f1))
            .Concat(" float->int=")
            .Concat(MathC.ToString(i5))
            .Concat(" double->long=")
            .Concat(MathC.ToString(l6))
            .Concat(" byte->double=")
            .Concat(MathC.ToString(d7))
            .Concat(" char->ushort=")
            .Concat(MathC.ToString(us9));

        String sums = "sumI=".Concat(MathC.ToString(sumI))
            .Concat(" sumL=")
            .Concat(MathC.ToString(sumL))
            .Concat(" sumD=")
            .Concat(MathC.ToString(sumD));

        Log.Header("conversions");
        Log.Item("inputs", inputs);
        Log.Item("samples", sample);
        Log.Item("sums", sums);

        Log.End("MathC conversions", t0);
    }
}

class AnyListTests {
    static void Run! {
        double t0 = Log.Begin("Any list");

        List list = List.New!;
        list.Add(String.Box("alpha"));
        Vector2 v = Vector2.New(1, 2);
        list.Add(Vector2.Box(v));
        Blob b = Blob.New(7, 1.5, v, "list");
        list.Add(Blob.Box(b));

        Log.Item("count", MathC.ToString(list.Count!));

        Any? a0 = list[0]; // list[0] is the same as list.Get(0)
        String? s0 = String.Unbox(a0);
        Log.Item("s0", s0 ?? "nil");

        Any? a1 = list[1];
        Vector2? v1 = Vector2.Unbox(a1);
        Log.Item("v1 ok", MathC.ToString(v1 != nil));

        Any? a2 = list[2];
        Blob? b1 = Blob.Unbox(a2);
        Log.Item("b1 ok", MathC.ToString(b1 != nil));

        Any? missing = list[99];
        Log.Item("missing nil", MathC.ToString(missing == nil));

        list.RemoveAt(1);
        Log.Item("after remove", MathC.ToString(list.Count!));

        Any? popped = list.Pop!;
        Log.Item("popped nil", MathC.ToString(popped == nil));

        list.Clear!;
        Log.Item("after clear", MathC.ToString(list.Count!));

        Log.End("Any list", t0);
    }

    static void Stress(int total) {
        double t0 = Log.Begin("Any list stress");
        List list = List.New!;

        int i = 0;
        while i < total;
        {
            String item = "item#".Concat(MathC.ToString(i));
            list.Add(item.Box!);
            i = i + 1;
        }

        Log.Line("count", MathC.ToString(list.Count!));

        int popped = 0;
        bool done = false;
        while popped < total && !done;
        {
            Any? v = list.Pop!;
            if v == nil;
                done = true;
            else
                popped = popped + 1;
        }

        Log.Line("popped", MathC.ToString(popped));
        Log.Line("final", MathC.ToString(list.Count!));
        Log.End("Any list stress", t0);
    }
}


class StressTests {
    static void Run(int itotal, int ikeepEvery) {
        double t0 = Log.Begin("Allocation stress");
        int total = itotal;
        int keepEvery = ikeepEvery;

        if keepEvery < 1;
            keepEvery = 1;

        if total < 1;
            total = 1;

        int reportEvery = total / 12;
        if reportEvery < keepEvery;
            reportEvery = keepEvery;

        if reportEvery < 1;
            reportEvery = 1;

        int i = 0;
        int nextReport = reportEvery;
        double lastReport = TimeMS!;
        while i < total;
        {
            int id = Counter.Next!;
            double v = MathC.ToDouble(i) * 0.1;
            float fx = MathC.ToFloat(i);
            float fy = MathC.ToFloat(i + 1);
            Vector2 pos = Vector2.New(fx, fy);
            String tag = "blob#".Concat(MathC.ToString(i));
            Blob b = Blob.New(id, v, pos, tag);

            if (i % keepEvery) == 0;
                Blob.KeepA = b;

            if (i % (keepEvery + 1)) == 0;
                Blob.KeepB = b;

            if i >= nextReport;
            {
                double now = TimeMS!;
                String msg = "i=".Concat(MathC.ToString(i))
                    .Concat(" dt=")
                    .Concat(MathC.ToString(now - lastReport))
                    .Concat(" created=")
                    .Concat(MathC.ToString(Counter.Created));
                Log.Line("alloc", msg);
                lastReport = now;
                nextReport = nextReport + reportEvery;
            }

            i = i + 1;
        }

        if Blob.KeepA == nil;
            Blob.KeepA = Blob.New(0, 0.0, Vector2.Zero, "fallback A");

        if Blob.KeepB == nil;
            Blob.KeepB = Blob.New(0, 0.0, Vector2.UnitX, "fallback B");

        String kept = "A=".Concat(Blob.KeepA.ToString!)
            .Concat(" | B=")
            .Concat(Blob.KeepB.ToString!);

        Log.Header("summary");
        Log.Item("total", MathC.ToString(total));
        Log.Item("keepEvery", MathC.ToString(keepEvery));
        Log.Item("reportEvery", MathC.ToString(reportEvery));
        Log.Item("created", MathC.ToString(Counter.Created));
        Log.Item("kept", kept);
        Log.End("Allocation stress", t0);
    }
}

class MemoryTests {
    static void Run! {
        double t0 = Log.Begin("Memory test (1 GB strings)");
        int entryCount = 1000000;
        int chunkLength = 1024;

        List entries = List.New!;
        double allocStart = TimeMS!;
        int i = 0;
        while i < entryCount;
        {
            String entry = MemoryTests.MakeChunk!;
            entries.Add(entry.Box!);
            i = i + 1;
        }
        double allocEnd = TimeMS!;

        Log.Line("entries held", MathC.ToString(entries.Count!));
        Log.Line("alloc ms", MathC.ToString(allocEnd - allocStart));

        double holdStart = TimeMS!;
        double holdUntil = holdStart + 1000;
        ulong spin = 0;
        while TimeMS! < holdUntil;
        {
            spin = spin + 1;
        }
        Log.Line("busy loops", MathC.ToString(spin));

        double releaseStart = TimeMS!;
        entries.Clear!;
        gc; // special gc statement to force gc
        double releaseEnd = TimeMS!;
        Log.Line("release ms", MathC.ToString(releaseEnd - releaseStart));
        Log.Line("after clear", MathC.ToString(entries.Count!));
        holdStart = TimeMS!;
        holdUntil = holdStart + 1000;
        spin = 0;
        while TimeMS! < holdUntil;
        {
            spin = spin + 1;
        }
        Log.Line("busy loops", MathC.ToString(spin));
        Log.End("Memory test (1 GB strings)", t0);
    }

    static String MakeChunk! => "                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                ";
}


